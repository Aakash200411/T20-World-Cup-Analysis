# -*- coding: utf-8 -*-
"""T20 World Cup Analysis 2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TsTn28SGL-zZTuvL-o5MgerB5416ZAne
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

import warnings
warnings.filterwarnings('ignore')

summary = pd.read_csv("/content/Match Summary.csv")
batting_summary = pd.read_csv("/content/Batting summaries for every match.csv")
bowling_summary = pd.read_csv("/content/Bowling summaries for every match.csv")
player_info = pd.read_csv("/content/Player_Info with Images T20 WC 2024.csv")

display(summary)

display(batting_summary)

display(bowling_summary)

# To link all the tables, we need to add 'match_id' data to batting and bowling tables
# to do so, first we need to create a dictionary of all the match_ids for all matches:
match_ids_dict = {}

for index, row in summary.iterrows():
    key1 = row['1st Team'] + ' Vs ' + row['2nd Team']
    key2 = row['2nd Team'] + ' Vs ' + row['1st Team']

    match_ids_dict[key1] = row['Match_Id']
    match_ids_dict[key2] = row['Match_Id']

#match_ids_dict

# Now we'll link this to the tables:
batting_summary['Match_Id'] = batting_summary['match'].map(match_ids_dict)
display(batting_summary)

bowling_summary['Match_Id'] = bowling_summary['match'].map(match_ids_dict)
display(bowling_summary)

display(player_info)

# Understanding the winning margin difference if won by runs:
winning_margin_runs = summary.loc[summary["Won by"] == 'Runs', 'Winning Margin']
print(winning_margin_runs.count())

sns.histplot(winning_margin_runs, kde = True, bins = 7)
plt.title('Distribution of Win Margins by Runs')
plt.ylabel('frequency')
plt.show()

# Understanding the winning margin difference if won by wickets:
winning_margin_runs = summary.loc[summary["Won by"] == 'Wickets', 'Winning Margin']
print(winning_margin_runs.count())

sns.histplot(winning_margin_runs, kde = True)
plt.title('Distribution of Win Margins by Wickets')
plt.ylabel('frequency')
plt.show()

# Create a boolean column indicating if the toss winner also won the match:
summary['Toss Win & Match Victory'] = summary['Toss Winning'] == summary['Winners']

# Count only rows where 'Toss Win & Match Victory' is True:
toss_win_count = summary['Toss Win & Match Victory'].sum()  # sum() counts True values as 1, False as 0
print("Count of matches where Toss Winner won the match:", toss_win_count)

# Calculate the win percentage based on the toss decision (includes all 52 matches):
toss_decision_impact = summary.groupby('Toss Decision')['Toss Win & Match Victory'].mean() * 100

# Plot the impact of toss decisions on match outcomes:
sns.barplot(x = toss_decision_impact.index, y = toss_decision_impact.values, palette = 'viridis')
plt.title('Impact of Toss Decisions on Match Outcomes')
plt.xlabel('Toss Decision')
plt.ylabel('Win Percentage')
plt.show()

# Display the win percentages
print(toss_decision_impact)

# Calculate top run scorers:
df_run = batting_summary.groupby('batsmanName')['runs'].sum().reset_index(name = 'total_runs')

df_run = df_run.sort_values(by='total_runs', ascending=False).head(20)

plt.figure(figsize=[20, 10])

# Set black facecolor for the entire plot
plt.gcf().set_facecolor('black')

# Plot title
plt.title('Top 20 Run Scorers in T20 World Cup 2024', fontsize=32, color='white')  # White title for contrast

# Barplot
barplot = sns.barplot(data = df_run, x = 'batsmanName', y = 'total_runs', palette='twilight')

# Labels
plt.xlabel('Player Name', fontsize=16, labelpad=30, color='white')  # White labels for contrast
plt.ylabel('Runs Scored', fontsize=16, labelpad=50, color='white')

# Adjust tick labels
plt.xticks(rotation=90, fontsize=14, color='white')  # White tick labels for visibility
plt.yticks(fontsize=14, color='white')

# Add the number of runs on top of each bar
for i, bar in enumerate(plt.gca().patches):
    plt.text(
        bar.get_x() + bar.get_width() / 2,
        bar.get_height(),
        f'{int(bar.get_height())}',
        ha='center', va='bottom', fontsize=12, color='white'  # White text for contrast
    )

barplot.set_facecolor('white')
plt.show()

# Calculate top wicket takers:
df_wckt = bowling_summary.groupby('bowlerName')['wickets'].sum().reset_index(name = 'total_wickets')

df_wckt = df_wckt.sort_values(by='total_wickets', ascending=False).head(20)

plt.figure(figsize=[20, 10])

# Set black facecolor for the entire plot
plt.gcf().set_facecolor('black')

# Plot title
plt.title('Top 20 Wicket-Takers in T20 World Cup 2024', fontsize=32, color='white')  # White title for contrast

# Barplot
barplot = sns.barplot(data = df_wckt, x = 'bowlerName', y = 'total_wickets', palette='twilight_shifted')

# Labels
plt.xlabel('Player Name', fontsize=16, labelpad=30, color='white')  # White labels for contrast
plt.ylabel('Wickets Taken', fontsize=16, labelpad=50, color='white')

# Adjust tick labels
plt.xticks(rotation=90, fontsize=14, color='white')  # White tick labels for visibility
plt.yticks(fontsize=14, color='white')

# Add the number of runs on top of each bar
for i, bar in enumerate(plt.gca().patches):
    plt.text(
        bar.get_x() + bar.get_width() / 2,
        bar.get_height(),
        f'{int(bar.get_height())}',
        ha='center', va='bottom', fontsize=12, color='white'  # White text for contrast
    )

barplot.set_facecolor('white')
plt.show()

# Calculating 'Runs % by Boundary' for each player:
def boundary_percent(group):
    total_runs = group['runs'].sum()
    total_fours = group['4s'].sum() * 4
    total_sixes = group['6s'].sum() * 6
    if total_runs == 0 or pd.isna(total_runs):  # Avoid division by zero
        return 0
    return (total_fours + total_sixes) / total_runs * 100

# Apply the function for each group and create a new DataFrame
df_boundary = batting_summary.groupby('batsmanName').apply(boundary_percent).round(2).reset_index(name='runs % by boundary')
display(df_boundary)

# Calculating 'SR' each player, then round to 2 decimal places:
# Convert object datatype to numeric for SR column:
batting_summary['SR'] = pd.to_numeric(batting_summary['SR'], errors = 'coerce')

def calculate_sr(group):
    total_runs = group['runs'].sum()
    total_balls = group['balls'].sum()

    batting_sr = round((total_runs / total_balls) * 100, 2)
    return batting_sr

df_sr = batting_summary.groupby('batsmanName').apply(calculate_sr).reset_index(name = 'batting_sr')
display(df_sr)


# Calculating 'batting average' for each player:
# Step 1: Define a function to calculate the batting average for each player
def calculate_average(group):
    total_runs = group['runs'].sum()  # Total runs scored by the player
    innings = group['runs'].count()   # Total innings played by the player
    not_out_innings = (group['out/not_out'] == 'not out').sum()  # Count of "not out" innings

    # Adjust the denominator to exclude not-out innings
    effective_innings = innings - not_out_innings if innings > not_out_innings else 1  # Avoid division by zero
    batting_average = round(total_runs / effective_innings, 2)
    return batting_average

# Step 2: Group by 'batsmanName' and apply the custom average function
df_avg = batting_summary.groupby('batsmanName').apply(calculate_average).reset_index(name = 'batting_avg')

# Display the resulting DataFrame with batting averages
display(df_avg)


# To check for batting average of a particular player:
rohit_avg = df_avg[df_avg['batsmanName'] == 'Rohit Sharma']
print(rohit_avg)

# Calculating avg balls faced by each batsman:
df_avg_balls = batting_summary.groupby('batsmanName')['balls'].mean().round().reset_index(name = 'avg_balls_faced')
display(df_avg_balls)

# Calculating batting position of each player:
# Step 1: Calculate appearance counts for each batting position per player
batting_position_counts = (
    batting_summary
    .groupby(['batsmanName', 'battingPos'])
    .size()
    .reset_index(name='count')
)

# Step 2: Find the majority position for each player
majority_positions = (
    batting_position_counts
    .sort_values('count', ascending=False)
    .drop_duplicates(subset='batsmanName')
)

# Step 3: Keep only 'batsmanName' and 'majorityPosition' columns
df_position = majority_positions[['batsmanName', 'battingPos']].rename(columns={'battingPos': 'majorityPosition'})

# Display the resulting DataFrame
display(df_position)

# Calculating total innings that a player has played this season:
df_innings = batting_summary.groupby('batsmanName')['runs'].count().reset_index(name = 'total_bat_innings')
display(df_innings)

# Calculating total runs scored by the batsman:
df_runs = batting_summary.groupby('batsmanName')['runs'].sum().reset_index(name = 'total_runs')
display(df_runs)

# Adding calculated columns to the original dataset:
combined_df_batting = batting_summary.copy()

# Merge each calculated DataFrame into combined_df
calculated_dfs = [df_avg, df_sr, df_boundary, df_avg_balls, df_position, df_innings, df_runs]

for calc_df in calculated_dfs:
    combined_df_batting = combined_df_batting.merge(calc_df, on='batsmanName', how='left')

# combined_df_batting.drop(columns = 'Match_Id', inplace = True)
display(combined_df_batting)

bowling_summary

# Define aggregation functions to calculate total values per player
def calculate_bowling_metrics(group):
    total_overs = group['overs'].sum()
    overs_int = group['overs'].apply(lambda x: int(x))        # Get integer part (whole overs)
    overs_balls = group['overs'].apply(lambda x: (x % 1) * 10) # Get decimal part (balls in incomplete over)

    # Calculate total balls bowled
    total_balls = (overs_int.sum() * 6) + overs_balls.sum()

    total_runs_conceded = group['runsConceded'].sum()
    total_wickets = group['wickets'].sum()

    # Bowling Average: Total Runs / Total Wickets
    bowling_avg = round(total_runs_conceded / total_wickets, 2) if total_wickets > 0 else 0

    # Bowling Strike Rate: Total Balls Bowled / Total Wickets
    bowling_sr = round(total_balls / total_wickets, 2) if total_wickets > 0 else 0

    # Bowling Economy: Total Runs / Total Overs
    bowling_ecn = round(total_runs_conceded / total_overs, 2) if total_overs > 0 else 0

    # Total Innings:
    total_innings = group['overs'].count()

    # Total Wickets:
    total_wickets = group['wickets'].sum()

    return pd.Series({
        'bowling_avg': bowling_avg,
        'bowling_sr': bowling_sr,
        'bowling_ecn': bowling_ecn,
        'total_bowl_innings': total_innings,
        'total_wickets': total_wickets
    })

# Group by 'bowlerName' and apply the metrics calculation function
df_bowling = bowling_summary.groupby('bowlerName').apply(calculate_bowling_metrics).reset_index()

# Display the final summary with bowling metrics for each player
display(df_bowling)

# Adding calculated columns to the original dataset:
combined_df_bowling = bowling_summary.copy()

combined_df_bowling = combined_df_bowling.merge(df_bowling, on='bowlerName', how='left')

# combined_df_bowling.drop(columns = 'Match_Id', inplace = True)
display(combined_df_bowling)

# Joining complete_batting_summary and player_info:
df_complete_batting_summary = pd.read_csv('/content/complete_batting_summary.csv')

batting_player_info = player_info.rename(columns = {'name':'batsmanName'})
# display(batting_player_info)

complete_batting_summary = df_complete_batting_summary.merge(batting_player_info, on = 'batsmanName', how = 'left')
display(complete_batting_summary)

# Joining complete_bowling_summary and player_info:
df_complete_bowling_summary = pd.read_csv('/content/complete_bowling_summary.csv')

bowling_player_info = player_info.rename(columns = {'name':'bowlerName'})
# display(bowling_player_info)

complete_bowling_summary = df_complete_bowling_summary.merge(bowling_player_info, on = 'bowlerName', how = 'left')
display(complete_bowling_summary)

bowling_player = df_complete_bowling_summary.rename(columns = {'bowlerName':'playerName'})
batting_player = df_complete_batting_summary.rename(columns = {'batsmanName':'playerName'})
all_player_info = player_info.rename(columns = {'name':'playerName'})
# display(all_player_info)
# display(bowling_player)
# display(batting_player)

half_merge = batting_player.merge(bowling_player, on = 'playerName', how = 'outer')
all_players = half_merge.merge(all_player_info, on = 'playerName', how = 'outer')
display(all_players)

# Best openers (2 required)
# Filter openers based on the given conditions
filtered_openers = complete_batting_summary[
    (complete_batting_summary['total_bat_innings'] >= 4) &
    (complete_batting_summary['batting_avg'] > 25) &
    (complete_batting_summary['batting_sr'] > 140) &
    (complete_batting_summary['runs % by boundary'] > 60) &
    (complete_batting_summary['majorityPosition'] < 4)
]

openers = filtered_openers.drop_duplicates(subset = 'batsmanName')
display(openers[['majorityPosition', 'batsmanName', 'team', 'batting_avg', 'batting_sr',
                'runs % by boundary', 'avg_balls_faced', 'total_bat_innings', 'role']])

"""**Based on runs % by boundary, our top 2 openers are going to be:**

1. Travis Head
2. Rohit Sharma
"""

# Best anchors (3 required)
# Filter middle order/anchors based on the given conditions
filtered_anchors = complete_batting_summary[
    (complete_batting_summary['total_bat_innings'] >= 4) &
    (complete_batting_summary['batting_avg'] > 35) &
    (complete_batting_summary['batting_sr'] > 130) &
    (complete_batting_summary['avg_balls_faced'] > 20) &
    (complete_batting_summary['majorityPosition'] > 2)
]

anchors = filtered_anchors.drop_duplicates(subset = 'batsmanName')
display(anchors[['majorityPosition', 'batsmanName','team', 'batting_avg', 'batting_sr',
                'runs % by boundary', 'avg_balls_faced', 'total_bat_innings', 'role']])

# Best finisher (1 required)
# Filter finishers based on the given conditions
filtered_finisher = all_players[
    (all_players['total_bat_innings'] >= 4) &
    (all_players['batting_avg'] > 20) &
    (all_players['batting_sr'] > 145) &
    (all_players['avg_balls_faced'] > 12) &
    (all_players['majorityPosition'] > 4) &
    (all_players['total_bowl_innings'] >= 3)
]

finisher = filtered_finisher.drop_duplicates(subset = 'playerName')
display(finisher[['majorityPosition', 'playerName', 'batting_avg', 'batting_sr',
                'runs % by boundary', 'avg_balls_faced', 'total_bat_innings', 'total_bowl_innings',
                'bowling_avg', 'bowling_sr', 'bowling_ecn', 'role']])

# Lower order/Allrounder spinners (2 required)
# Filter spinners based on the given conditions
filtered_spinners = all_players[
    (all_players['total_bat_innings'] >= 2) &
    (all_players['batting_avg'] > 15) &
    (all_players['batting_sr'] > 120) &
    (all_players['bowling_sr'] < 18) &
    (all_players['bowling_ecn'] < 8) &
    (all_players['total_bowl_innings'] >= 4) &
    (all_players['bowling_style'].str.contains('Googly|Offbreak|Orthodox|Wrist', regex = True))
]

spinners = filtered_spinners.drop_duplicates(subset = 'playerName')
display(spinners[['majorityPosition', 'playerName', 'batting_avg', 'batting_sr',
                'runs % by boundary', 'avg_balls_faced', 'total_bat_innings', 'total_bowl_innings',
                'bowling_avg', 'bowling_sr', 'bowling_ecn', 'role', 'total_wickets', 'bowling_style']])

# Best fast bowlers (3 required)
# Filter fast bowlers based on the given conditions
filtered_fast_bowlers = complete_bowling_summary[
    (complete_bowling_summary['total_bowl_innings'] >= 4) &
    (complete_bowling_summary['bowling_avg'] < 20) &
    (complete_bowling_summary['bowling_sr'] < 14) &
    (complete_bowling_summary['bowling_ecn'] < 7) &
    (complete_bowling_summary['bowling_style'].str.contains('Fast|Medium|fast'))
]

fast_bowlers = filtered_fast_bowlers.drop_duplicates(subset = 'bowlerName')
display(fast_bowlers[['bowlerName', 'team', 'total_bowl_innings', 'bowling_avg', 'bowling_sr',
                      'bowling_ecn', 'role', 'total_wickets', 'bowling_style']])

"""**Final Dream Team**
1. Travis Head
2. Rohit Sharma
3. Nicholas Pooran
4. Harry Brook
5. Marcus Stoinis
6. Hardik Pandya
7. Roston Chase
8. Axar Patel
9. Jasprit Bumrah
10. Trent Boult
11. Fazalhaq Farooqi

Squad is of 15 players and hence based on players performance, we've got 4 reserves.
These are:

12. Jos Buttler
13. Andries Gous
14. Andre Russell
15. Rashid Khan
"""

